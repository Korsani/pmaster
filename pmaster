#!/usr/bin/env perl
use warnings;
use strict;
use Data::Dumper;
use Term::ANSIColor qw(:constants colorstrip);
use File::Temp;
use Pod::Usage;
use Getopt::Long;
use File::Copy;
use DBI;
use Sys::Syslog qw( :standard :macros );
use Time::HiRes;
use constant VERSION	=> 0.7;

use constant DB_FILE	=> 'pmaster.db';
use constant DB_DIR		=> '/var/db';
use constant DB_VERS	=> 2;
use constant PM_OPTS	=> '-dbg';

use vars qw( $HELP $EXISTS $ALL $DEBUG $CURRENT $PROGRESS $LAST $VERSION $WAIT $STATS $SHOWWORLD $ADDWORLD $RMWORLD $ONESHOT $DRYRUN );

die "Not on FreeBSD\n" unless ("$^O" =~ "freebsd");

GetOptions(
	'help'		=> \$HELP,
	'exists'	=> \$EXISTS,
	'all'		=> \$ALL,
	'debug'		=> \$DEBUG,
	'current'	=> \$CURRENT,
	'progress'	=> \$PROGRESS,
	'last'		=> \$LAST,
	'version'	=> \$VERSION,
	'wait=i'	=> \$WAIT,
	'stats'		=> \$STATS,
	'oneshot|1'	=> \$ONESHOT,
	'dryrun|n'	=> \$DRYRUN,
	'ls-world'	=> \$SHOWWORLD,
	'add-world'	=> \$ADDWORLD,
	'rm-world'	=> \$RMWORLD
);
if ($VERSION) {
	printf("%s\n",VERSION);
	exit 0;
}

if ($HELP) {
	pod2usage(-verbose => 2);
	exit;
}

my $DRIVER='SQLite';
my $DSN="DBI:$DRIVER:dbname=".DB_DIR.'/'.DB_FILE;
my %table=(
	'stats'=>'pmaster_stats',
	'config'=>'pmaster_config'
);
# Sql statements to create table
my %create_table=(
	# 'time_user', 'time_sys', 'os' are unused
	$table{'stats'} => 'CREATE TABLE '.$table{'stats'}.' (id integer primary key autoincrement, timestamp timestamp DEFAULT CURRENT_TIMESTAMP, origin text, time_real float, time_user float, time_sys float,portmaster_options text, mac text,os text, kernel_vers text, arch text, cpu_freq integer, memory integer, ccache bool, log_size_lines integer);',
	$table{'config'} => 'CREATE TABLE '.$table{'config'}.' (key text type uniq, value text);'
);
# Sql statements to update database
my %update_table=(
	2=>'alter table '.$table{'stats'}.' add world boolean default true'
);

our %env;
our %exit_code;
our %time_taken;

sub disp2 {
	my %msg=%{shift()};
	$msg{'prefix'}=1 if (not defined $msg{'prefix'});
	if ($msg{'prefix'}) {
		my $sub;
		if (caller(1)) {
			$sub=(split(/::/,(caller(1))[3]))[1];
		} else {
			$sub='main';
		}
		my $line=(caller(0))[2];
		$msg{'prefix'}=sprintf('['.YELLOW.'pmaster'.RESET.']('.CYAN.'%s:%s'.RESET.') ',$sub,$line);
	} else {
		$msg{'prefix'}='';
	}
	my $msg=sprintf('%s'.$msg{'msg'}."\n",$msg{'prefix'},@{$msg{'params'}});
	if (-t STDOUT) {
		print($msg);
	} else {
		print(colorstrip($msg));
	}
}
sub check_db_tables {
	my $dbh=shift;
	# Let's check if tables exists
	foreach my $table (values %table) {
		if (! $dbh->selectall_array('SELECT name FROM sqlite_master WHERE type="table" AND name="'.$table.'";')) {
			my @res=$dbh->selectall_array($create_table{$table});
			disp2({msg=>"Table %s created",params=>[$table]});
		} elsif ($DEBUG) {
			disp2({msg=>"Table %s ok",params=>[$table]});
		}
	}
}
sub check_db_version {
	my $dbh=shift;
	my $sql=sprintf('select value from %s where key="%s";',$table{'config'},'db_vers');
	my $db_vers=$dbh->selectall_array($sql);
	# None? Maybe db is juste created
	if($db_vers == 0) {;
		$sql=sprintf('insert into %s (key,value) values ("db_vers",%i);',$table{'config'},DB_VERS);
		$dbh->selectall_array($sql);
		disp2({msg=>'Db version set to %i',params=>[DB_VERS]});
	} elsif ($db_vers < DB_VERS) {		# Time to upgrade!
		foreach my $i ($db_vers+1..DB_VERS) {
			$dbh->selectall_array($update_table{$i});
			$sql=sprintf('update %s set value=%i where key="db_vers";',$table{'config'},$i);
			$dbh->selectall_array($sql);
			disp2({msg=>'Database schema version set to %d',params=>[$i]}) if ($DEBUG);
		}
	} else {
		disp2({msg=>'Database schema version: %d',params=>[$db_vers]}) if ($DEBUG);
	}
}
sub check_db_path {
	for my $dir ($ENV{'HOME'}) {
		if ( -e $dir.'/'.DB_FILE) {
			disp2({msg=>'Moving %s from %s to %s',params=>[DB_FILE,$dir,DB_DIR]});
			move($dir.'/'.DB_FILE,DB_DIR);
		}
	}
}
sub check_db {
	my $dbh=shift;
	check_db_path($dbh);
	check_db_tables($dbh);
	check_db_version($dbh);
}
# Function to get ports(7) variable's values
# For that, I ask a Makefile to display me vars and values
sub get_make_var {
	my $var=shift;
	my $uvar=uc($var);
	my $fh=File::Temp->new();
	print $fh "CATEGORIES=devel\n.include <bsd.port.mk>\ninfo:\n\t\@echo ".$uvar."=\$(".$uvar.")";
	open(M,'make -f '.$fh->filename.' info|') or die "$!";
	while (my $line=<M>) {
		if ($line=~/^$uvar=(.*)/) {
			return $1;
		}
	}
}
sub get_make_vars {
	my $dbh=shift;
	my @vars=('PORTSDIR','WRKDIRPREFIX','WITH_CCACHE_BUILD');
	foreach my $var (@vars) {
		my @res=$dbh->selectall_array('select value from '.$table{'config'}.' where key="'.uc($var).'";');
		if(scalar @res == 0) {
			disp2({msg=>'No var %s found in config. Getting it',params=>[$var]}) if ($DEBUG);
			my $value=get_make_var($var);
			$dbh->selectall_array('insert into '.$table{'config'}.' (key,value) values ("'.$var.'","'.$value.'");');
			$env{$var}=$value;
		} else {
			$env{$var}=@{ shift @res }[0];
		}
	}
}
# Get average compile time of a port
sub get_port_stats {
	my $dbh=shift;
	my $o=shift;
	my $sql='select avg(time_real) from '.$table{'stats'}.' where origin="'.$o.'"';
	my @res=$dbh->selectall_array($sql);
	if (scalar @res == 0) {
		return undef;
	} else {
		return shift @{ shift @res };
	}
}
# Return given field
sub get_db_infos {
	my $dbh=shift;
	my $o=shift;
	my $field=shift;
	my $sql='select id,'.$field.' from '.$table{'stats'}.' where origin="'.$o.'" order by id';
	my @res=$dbh->selectall_array($sql);
	if (scalar @res == 0) {
		return undef;
	} else {
		return @res;
	}
}
# Translate arbitrary string to a port name
sub resolve_origin {
	my $dbh=shift;
	my @origins;
	my $kvers=`uname -K`;
	chomp $kvers;
	$kvers=~s/^(..).*/$1/;
	while (my $pkg=shift) {
		disp2({msg=>'Resolving '.BRIGHT_WHITE.'%s'.RESET,params=>[$pkg]}) if ($DEBUG);
		my @ports=`pkg info -o $pkg 2>/dev/null | awk '{print \$2}'`;
		chomp @ports;
		if ( scalar @ports == 0) {
			disp2({msg=>'Not found by pkg(1). Searching in INDEX'}) if ($DEBUG);
			# So it's a package I don't know about. Let's search in INDEX
			open(I,"<$env{PORTSDIR}/INDEX-$kvers") or die "$!";
			while (my $line = <I>) {
				if ($line =~ /$env{PORTSDIR}\/[\w\-]*\/$pkg\|/i) {
					my $port=((split(/\|/,$line))[1]);
					$port=~s/$env{PORTSDIR}\///;
					push @ports,$port;
				}
			}
			close(I);
		}
		if (scalar @ports == 0) {
			disp2({msg=>'No origin found for '.BRIGHT_WHITE.'%s'.RESET,params=>[$pkg]});
		} elsif (scalar @ports == 1) {
			disp2({msg=>'%s ~> %s',params=>[$pkg,$ports[0]]}) if ($DEBUG);
			push @origins,($ports[0]);
		} else {
			disp2({msg=>'More than one origin found for %s',params=>[$pkg]}) if ($DEBUG);
		}
	}
	return @origins;
}
sub show_stats {
	my $dbh=shift;
	my @pkgs=@_;
	if ($ALL) {
		foreach my $e ($dbh->selectall_array('select origin from '.$table{'stats'}.' group by origin order by origin;')) {
			push @pkgs,(shift @{$e});
		}
	}
	# Display stats of given ports
	foreach my $port (@pkgs) {
		$port=~s!$env{'PORTSDIR'}/(.*)!$1!;
		my $sql='select timestamp,time_real from '.$table{'stats'}.' where origin="'.$port.'"';
		my @res=$dbh->selectall_array($sql);
		if (scalar @res > 0) {	
			my @times;
			foreach my $e (@res) {
				push @times,(join(' => ',@{ $e }));
			}
			disp2({prefix=>0,msg=>YELLOW.'%s'.RESET.":\n\t".CYAN."Average duration:".RESET." %0is\n\t".CYAN."Series: \n".RESET."%s",params=>[$port,get_port_stats($dbh,$port),join("\n",@times)]});
		}
	}
}
sub get_port_dependance {
	my $origin=shift;
	disp2({msg=>'Gathering dependance of '.BRIGHT_WHITE.'%s'.RESET,params=>[$origin]});
	open(W,"portmaster --show-work $origin | grep 'NOT INSTALLED' | awk '{print \$4}'|") or die "$!";
	my @dependencies=<W>;
	chomp @dependencies;
	return(@dependencies);
}
# Run compilation of a port
sub build_port {
	my $dbh=shift;
	my $port=shift;
	my $world=shift;
	my @dependencies=get_port_dependance($port);
	if (scalar @dependencies gt 0) {
		map {disp2({msg=>'> '.BRIGHT_WHITE.'%s'.RESET,params=>[$_]})} @dependencies;
		foreach my $port (@dependencies) {
			build_port($dbh,$port,0);
		}
	}
	my @a=get_db_infos($dbh,$port,'log_size_lines');
	# Returns [ [ id, field ] [ ... ] ]
	# And I want the field of the last element
	my $lines=@{ $a[-1]}[1];
	my $time=get_port_stats($dbh,$port)||'?';
	disp2({msg=>'Building '.BRIGHT_WHITE.'%s'.RESET.' (~'.BRIGHT_WHITE.'%s'.RESET.'s)',params=>[$port,$time]});
	if ($DRYRUN) {
		disp2({msg=>'Dry run asked'});
		return(0,0);
	}
	# If line size is available and progress is asked
	my $start=Time::HiRes::time();
	my $ec=0;
	if ($lines and $PROGRESS) {
		my $cmd='portmaster '.PM_OPTS.' '.$port." | pv -l -s $lines -pet >/dev/null";
		$ec=system($cmd);
	} else {
		$lines=0;
		open(P,'portmaster --no-confirm '.PM_OPTS.' '.$port.'|') or $ec=1;
		while(<P>) {
			$lines++;
			print;
		}
		close(P);
		$ec=$?;
	}
	my $end=Time::HiRes::time();
	parse_stats($dbh,$port,($end-$start));
	# If everything went fine...
	if ($ec == 0) {
		store_stats($dbh,$port,($end-$start),$lines,$world);
		disp2({msg=>BRIGHT_WHITE.'%s'.RESET.' added to '.BRIGHT_BLUE.'world'.RESET,params=>[$port]}) if ($world);
	} else {
		disp2({msg=>'Something failed with %s building: portmaster exits with %i',params=>[$port,$ec/256]});
	}
	return(($ec/256,$end-$start));
}
sub parse_stats {
	my $dbh=shift; my $o=shift; my $real=shift;
	my $time=get_port_stats($dbh,$o)||1;
	disp2({msg=>'%s: '.BRIGHT_WHITE.'%is'.RESET.'? %is! d:%is s:%-.02f%%',params=>[$o,$time,$real,$real-$time,$real*100/$time]});
}

# Store stats to database
sub store_stats {
	my $dbh=shift; my $o=shift; my $real=shift; my $lines=shift; my $world=shift;
	my $mac=`uname -m|xargs echo -n`;		# Machine type (amd64, arm64, ...)
	my $kvers=`uname -K|xargs`;	# Kerner version (1201000, ...)
	my $arch=`uname -p|xargs`;	# Arch (amd64, aarch64,...
	my $mem=`sysctl -n hw.physmem|xargs`;		# Physical amount of memory
	my $cfreq=`sysctl -n dev.cpu.0.freq|xargs`;	# Cpu freq. May vary by sake of powerd(8)/powerdxx(8)
	my $sql=sprintf("insert into %s (origin,time_real,portmaster_options,mac,kernel_vers,arch,cpu_freq,memory,ccache,log_size_lines,world) values ('%s',%i,'%s','%s','%s','%s',%i,%i,%i,%i,%d);select last_insert_rowid();",$table{'stats'},$o,	$real,PM_OPTS, `uname -m| xargs echo -n`,`uname -K|xargs echo -n`,`uname -p | xargs echo -n`,`sysctl -n dev.cpu.0.freq| xargs echo -n`, `sysctl -n hw.physmem| xargs echo -n`, $env{'WITH_CCACHE_BUILD'} eq 'yes' ? 1 : 0, $lines,$world);
	$dbh->selectall_array($sql);
}
sub loop_on_me {
	my $dbh=shift;
	my $a=shift;
	while (1) {
		if ($a) {
			foreach my $k (keys %{$a}) {
				my $mess=sprintf('%s:%s%%',$a->{$k}{'port'},$a->{$k}{'progress'});
				syslog(LOG_INFO,$mess);
			}
		}
		$a=get_running_port($dbh);
		sleep($WAIT);
	}
}
sub get_running_port {
	my $dbh=shift,
	my @list=glob ( "$env{'WRKDIRPREFIX'}$env{'PORTSDIR'}/*/*/work*" );
	my %res;
	if (scalar @list == 0) {
		disp2({msg=>'No ongoing work found',params=>[]}) unless ($WAIT);
		return \%res;
	}
	foreach my $w (@list) {
		my $port=$w;
		$port=~s!$env{'WRKDIRPREFIX'}$env{'PORTSDIR'}/(.*)/work.*!$1!;
		disp2({msg=>'Dealing with '.BRIGHT_WHITE.'%s'.RESET.' ~ %s',params=>[$w,$port]}) if ($DEBUG);
		# This is the best way I found to detect ongoing portmaster:
		# There should have more at least one process with `make` and $WRKDIRPREFIX$PORTSDIR<port>/work somewhere...
		my $npid=`ps -a | grep -v grep | grep '$w' | awk '{print \$1}'| wc -l|xargs`;
		chomp $npid;
		if ($npid > 0) {
			exit 0 if ($EXISTS);
			disp2({msg=>'Compilation in '.BRIGHT_WHITE.'%s'.RESET.' is ongoing',params=>[$w]}) if ($DEBUG);
			# When base dir has been created?
			my @stats=stat($env{'WRKDIRPREFIX'}.$env{'PORTSDIR'}.'/'.$port);
			my $eta='?';my $progress='?';
			if (my $time = get_port_stats($dbh,$port)) {
				$eta=sprintf('%0i',$time-(Time::HiRes::time()-$stats[10]));
				$progress=sprintf('%2i',($time-$eta)/$time*100);
			}
			$res{$port}={port=>$port,start_time=>$stats[10],eta=>$eta,progress=>$progress};
		} else {
			disp2({msg=>'No process seems to handle compilation in '.BRIGHT_WHITE.'%s'.RESET,params=>[$w]}) if ($DEBUG);
		}
	}
	if (scalar keys %res == 0) {
		disp2({msg=>BRIGHT_WHITE.'%d stall work(s) found:'.RESET,params=>[scalar @list]}) if ($DEBUG or ! $WAIT);
		foreach my $w (@list) {
			disp2({msg=>'> %s',params=>[$w]}) if ($DEBUG or ! $WAIT);
		}
	}
	return \%res;
}
sub list_world {
	my $dbh=shift;
	my $sql=sprintf('select origin from %s where world = 1 group by origin order by origin',$table{stats});
	my @res=$dbh->selectall_array($sql);
	return \@res;
}

my $dbh=DBI->connect($DSN,'','',{RaiseError => 1}) or die $DBI::errstr;
disp2({msg=>"Database:%s",params=>[$DSN]}) if ($DEBUG);

check_db($dbh);

# == let's run

my @pkgs;
if (scalar @ARGV ne 0) {
	@pkgs=@ARGV;
}
if ($LAST) {
	my $sql='select origin from '.$table{'stats'}.' order by id desc limit 1;';
	my @e=$dbh->selectall_array($sql);
	push @pkgs,(shift @{shift @e});
	$STATS=1;
}
get_make_vars($dbh);
@pkgs=resolve_origin($dbh,@pkgs);

# Just show stats of given ports
if ($STATS and (scalar @pkgs > 0 or $ALL)) {	# show stats about a package
	show_stats($dbh,@pkgs);
	exit 0;
} elsif ($CURRENT) {					# Show what portmaster is currently doing
	openlog('pmaster','ndelay,pid','local0');
	my $a=get_running_port($dbh);
	if ($a) {
		my $i=1;
		foreach my $k (keys %{$a}) {
			disp2({prefix=>0,msg=>WHITE.'<'.$i++.'>'.RESET.' '.YELLOW.'%s'.RESET.":\n\t".CYAN.'Started'.RESET.": %s\n\t".CYAN.'Elapsed'.RESET.": %0is\n\t".CYAN.'ETA'.RESET.": %s\n\t".CYAN.'Progress'.RESET.": %2s%%",params=>[$a->{$k}{'port'},scalar localtime $a->{$k}{'start_time'},Time::HiRes::time()-$a->{$k}{'start_time'},($a->{$k}{'eta'} eq '?'?'?' : ($a->{$k}{'eta'}.'s ('.scalar localtime (time()+$a->{$k}{'eta'})).')'),$a->{$k}{'progress'}]});
		}
	}
} elsif ($WAIT) {
	my $a=get_running_port($dbh);
	openlog('pmaster','ndelay,pid','local0');
	if ($a) {
		loop_on_me($dbh,$a);
	} else {
		loop_on_me($dbh,{port=>'(idle)',progress=>'?',eta=>0});
	}
} elsif ($SHOWWORLD) {
	my $res=list_world($dbh);
	if (scalar @{$res} > 0) {
		foreach my $aport (@{$res}) {
			my $port=shift @{$aport};
			system("pkg info -e $port");
			# Display only installed ports
			disp2({prefix=>0,msg=>'%s',params=>[$port]}) if ($?==0);
		}
	} 
} elsif ($RMWORLD) {
	my $sql='update %s set world=false where origin="%s"';
	foreach my $port (@pkgs) {
		disp2({msg=>'Puting '.BRIGHT_WHITE.'%s'.RESET.' out of '.BRIGHT_BLUE.'world'.RESET,params=>[$port]});
		$sql=sprintf($sql,$table{'stats'},$port);
		$dbh->selectall_array($sql);
	}
} elsif ($ADDWORLD) {
	my $sql='update %s set world=true where origin="%s"';
	foreach my $port (@pkgs) {
		disp2({msg=>'Puting '.BRIGHT_WHITE.'%s'.RESET.' in '.BRIGHT_BLUE.'world'.RESET,params=>[$port]});
		$sql=sprintf($sql,$table{'stats'},$port);
		$dbh->selectall_array($sql);
	}
} else {		# Compile ports
	if (scalar @pkgs == 0) {
		disp2({msg=>'Nothing to build'});
	}
	foreach my $port (@pkgs) {
		($exit_code{$port},$time_taken{$port})=build_port($dbh,$port,$ONESHOT?0:1);
	}
	if (scalar keys %exit_code > 0) {
		disp2({msg=>'Summary:'});
		map {disp2({msg=>'- %s%s:%s (in %is)',params=>[$ONESHOT?'':BRIGHT_BLUE.'w'.RESET.':',$_,$exit_code{$_}==0?BRIGHT_GREEN.'success'.RESET:BRIGHT_RED.'failure'.RESET,$time_taken{$_}]});} @pkgs;
	}
}

=pod

=head1 NAME

	pmaster

=head1 SYNOPSIS

	pmaster [ --debug ] [ --progress ] [ --oneshot|-1 ] [ --dryrun ] <port>
	pmaster [ --debug ] --current 
	pmaster [ --debug ] --exists
	pmaster [ --debug ] --last
	pmaster [ --debug ] --stats <port>|--all
	pmaster [ --debug ] --wait <n>
	pmaster [ --debug ] --ls-world | --add-world | --rm-world
	pmaster --help

=head1 DESCRIPTION

Wrapper for portmaster(8) to add some functionalities, such as:

- Currently port building,
- Estimated time for a build,
- A `world` list, as Gentoo has

It uses a sqlite3(1) database.

=head1 OPTIONS

=over

=item <port>

Build this port with portmaster(8).

=item --current

Show currently building port.

=item --debug

Show debugging informations.

=item --dryrun

Does everything except building the port and writing into db.

=item --exists

Immediatly return with true if a compilation is running.

=item --help

Help?

=item --last

Show last built port. Implies B<--stats>.

=item --oneshot

Do not flag port as part of `world` list.

=item --stats

Show statistics about port(s), or all if B<--all> is specified.

=item --wait

Wait forever, logging to syslog every B<n> seconds what's going on.

=item --ls-world, --add-world, --rm-world

Show/add/remove ports from `world` list.

In Gentoo, the `world` file is a list of packages you intended to built and that should be auto removed. Ports built by pmaster(1) are flagged `world` by default.

Please note it does not keep track of package installer via pkg(8) or other package manager.

=back

=cut
